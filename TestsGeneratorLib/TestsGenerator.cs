using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;

namespace TestsGeneratorLib
{
    /// <summary>
    ///  https://docs.microsoft.com/en-us/dotnet/standard/io/asynchronous-file-i-o
    /// </summary>
    public class TestsGenerator
    {
        private readonly int _readFileThreadsAmount;
        private readonly int _processedTasksThreadsAmount;
        private readonly int _writeFileThreadsAmount;

        public TestsGenerator(int readFileThreadsAmount, int processedTasksThreadsAmount, int writeFileThreadsAmount)
        {
            _readFileThreadsAmount = readFileThreadsAmount;
            _processedTasksThreadsAmount = processedTasksThreadsAmount;
            _writeFileThreadsAmount = writeFileThreadsAmount;
        }

        public Task GenerateCLasses(IEnumerable<string> classPaths, string testPath)
        {
            var maxFilesToLoad = new ExecutionDataflowBlockOptions() { MaxDegreeOfParallelism = _readFileThreadsAmount };
            var maxTestToGenerate = new ExecutionDataflowBlockOptions() {MaxDegreeOfParallelism = _processedTasksThreadsAmount};
            var maxFilesToWrite = new ExecutionDataflowBlockOptions() {MaxDegreeOfParallelism = _writeFileThreadsAmount};

            // Create a dataflow block that takes a  path as input and returns a file text
            var loadClasses = new TransformBlock<string, string> (GetTextFromFile,maxFilesToLoad); // add lambda and try/catch
            
            // Create a dataflow block that takes a file text and return generated Tests
            var generateTests = new TransformBlock<string, string[]>(GetTestFromText, maxTestToGenerate); // add lambda and try/catch
            
            // Create a dataflow block that save generated Test on disk 
            var writeTests = new ActionBlock<string[]>(WriteTests, maxFilesToWrite); // add lambda and try/catch
            
            //
            // Connect the dataflow blocks to form a pipeline.
            // 
            var linkOption = new DataflowLinkOptions
            {
                PropagateCompletion = true
            };
            loadClasses.LinkTo(generateTests, linkOption);
            generateTests.LinkTo(writeTests, linkOption);

            foreach (var path in classPaths)
            {
                loadClasses.Post(path);
            }
            
            // Mark the head of the pipeline as complete.
            loadClasses.Completion.Wait();

            return writeTests.Completion;
        }

        private static async Task<string> GetTextFromFile(string path)
        {
            using var sourceStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read,
                bufferSize: 4096, useAsync: true);

            var sb = new StringBuilder();

            var buffer = new byte[0x1000];
            int numRead;
            
            
            while ((numRead = await sourceStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
            {
                var text = Encoding.UTF8.GetString(buffer, 0, numRead);
                sb.Append(text);
            }

            return sb.ToString();
        }

        private static async Task<string[]> GetTestFromText(string text)
        {
            var classes = GetClassesFromText(text);
            foreach (var classDeclaration in classes)
            {
                CreateTest(classDeclaration);
            }
            return null;
        }

        /// <summary>
        /// https://blog.zwezdin.com/2013/code-generating-with-roslyn/
        /// </summary>
        /// <param name="classDeclaration"></param>
        private static string CreateTest(BaseTypeDeclarationSyntax classDeclaration)
        {
            // add methods
            var methods = classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>();
            var members = new List<MethodDeclarationSyntax>();
            
            foreach (var method in methods)
            {
                var methodBody = SyntaxFactory.ParseStatement("Assert.Fail(\"autogenerated\");");
                
                var member = SyntaxFactory
                    .MethodDeclaration(SyntaxFactory.ParseName("void"), method.Identifier.Text + "Test")
                    .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword)).AddTypeParameterListParameters()
                    .WithBody(SyntaxFactory.Block(methodBody))
                    .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("Test")))));
                members.Add(member);
            }
            
            // add class declaration
            var @class = SyntaxFactory.ClassDeclaration(classDeclaration.Identifier.Text + "Test")
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddAttributeLists(SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(
                    SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("TestFixture"))))).
                AddMembers(members.ToArray());
            
            
            // add namespace declaration 
            string classNamespaceName = null;
            
            if (!SyntaxNodeHelper.TryGetParentSyntax(classDeclaration, out NamespaceDeclarationSyntax namespaceDeclarationSyntax))
            {
                classNamespaceName = namespaceDeclarationSyntax.Name.ToString();
            }
            var @namespace = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(classNamespaceName ?? "Kra" + ".Test")).AddMembers(@class);

            var test = SyntaxFactory.CompilationUnit()
                .AddUsings(
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")),
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Collections.Generic")),
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Linq")),
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Text")),
                SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("NUnit.Framework"))
                )
                .AddMembers(@namespace)
                .NormalizeWhitespace()
                .ToString();
            
            return test;
        }

        private static IEnumerable<ClassDeclarationSyntax> GetClassesFromText(string text)
        {
            var tree = CSharpSyntaxTree.ParseText(text);
            return tree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();
        }
        
        
        

        private static async Task WriteTests(string[] tests)
        {
            var filePath = "";

            foreach (var test in tests)
            {
                var encodedText = Encoding.Unicode.GetBytes(test);

                using var sourceStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None,
                    bufferSize: 4096, useAsync: true);

                await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
            }
        }

    }
    
}